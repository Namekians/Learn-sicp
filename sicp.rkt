#lang racket
(define (square x) (* x x))
(define (avg x y) (/ (+ x y) 2))
(define (abs x) (if (> x 0) x (- x)))

;square root
(define (sqrt x)
  (define (sqrt-iter guess)(if (good-enough? guess) guess (sqrt-iter (improve-guess guess))))
  (define (good-enough? guess) (if (< (/ (abs (-(improve-guess guess) guess)) guess) 0.001) #t #f))
  (define (improve-guess guess) (avg guess (/ x guess)))
  (sqrt-iter 1.0))
;cube root
(define (cube-root guess x) (if (good-enough-cube? guess x)   guess   (cube-root (improve-guess-cube guess x) x) ))
(define (good-enough-cube? guess x)(if (< (/ (abs (- (improve-guess-cube guess x) guess)) guess) 0.001) #t #f))
(define (improve-guess-cube guess x)(/ (+ (/ x (square guess)) (* 2 guess)) 3))

;f(n) = f(n-1)+2f(n-2)+3f(n-3)
(define (iterative-f n)
  (define (iter-f n3 n2 n1 count) (cond ((< (- count 3) 0) count)
                                      ((= (- count 3) 0) (+ n3 (* 2 n2) (* 3 n1)))
                                      (else (iter-f  (+ n3 (* 2 n2) (* 3 n1)) n3 n2 (- count 1) ))))
  (iter-f 2 1 0 n)
  )
(define (recursive-f n)(if (< n 3) n (+ (recursive-f (- n 1)) (* 2 (recursive-f (- n 2))) (* 3 (recursive-f (- n 3))))))



;pascal's triangle, let x be the row and y be the column
(define (pascal-triangle x y)
  (if (or (= y 1) (= y x))
      1
  (+ (pascal-triangle (- x 1) (- y 1))  (pascal-triangle (- x 1) y ) )
  ))

;Fibonacci
(define (fib n)
  (define (fib-iter a b count)
    (if (= count 0)  a (fib-iter b (+ a b) (- count 1)))
    )
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else   (fib-iter 0 1 n))
        )
  )
(define sqr-5-a (/ (+ 1 (sqrt 5)) 2))
(define sqr-5-b (/ (- 1 (sqrt 5)) 2))
(define (calc n) (/ (- (pow sqr-5-a n) (pow sqr-5-b n)) (sqrt 5)))
; original power
(define (pow num nth)
  (define (pow-iter num res nth)  (if(= nth 0) res (pow-iter num (* res num) (- nth 1))))
  (pow-iter num 1 nth)
)
(define (even? x)(= (remainder x 2)0) )
; fast power 
(define (fast-pow b n)
  (define (fast-row-iter remain res base)(cond ((= remain 0) res)
                                          ((even? remain) (fast-row-iter (/ remain 2) res (square base)))
                                          (else (fast-row-iter (- remain 1) (* res base) base ))))
  (fast-row-iter n 1 b)
  )
; do multiply using double and half
(define (double x) (+ x x))
(define (half x) (/ x 2))
(define (fast-multiply a b)
  (define (fast-multiply-iter remain res base)
    (cond ((= remain 0) res)
          ((even? remain) (fast-multiply-iter (half remain) res (double base)))
          (else (fast-multiply-iter (- remain 1) (+ res base) base))
          )
    )
  (fast-multiply-iter b 0 a)
  )
(define (fast-multiply-recur a b)
   (cond ((= b 1) a)
         ((even? b) (double (fast-multiply-recur a (half b))))
         (else (+ a (fast-multiply-recur a (- b 1)))))
  )
; find prime factor 
(define (smallest-divisor t test-divisor)
  (define (next d)(if (= d 2) 3 (+ d 2)))
  (define (divides? a b)(= (remainder a b) 0))
  (cond ((> (square test-divisor) t) t)
        ((divides? t test-divisor) test-divisor)
        (else (smallest-divisor t (next test-divisor)))
  ))


(define (prime? x)
  (= (smallest-divisor x 2) x))
; Fermat
(define (expo-module base exp m)
  (cond ((= exp 1) base)
        ((even? exp)(remainder (square (expo-module base (/ exp 2) m)) m))
        (else (remainder (* base (expo-module  base (- exp 1) m)) m)))
  )
(define (fermat-test n)
  (let ((a (+ 1(random (- n 1)))))(= (expo-module a n n) a ))
  )
(define (Carmichael-numbers n)
  (define (CN-iter count n)
    (cond ((> count (- n 1)) #t)
          ((= (expo-module count n n) count) (CN-iter (+ 1 count) n))
          (else #f)                               )
    )
  (CN-iter 1 n)
  )
 ; Higher-order procedures
(define (h-sum f a next b)
  (if (> a b)
      0
      (+ (f a) (h-sum f (next a) next b)))
  )

;integral of a function
(define (integral f a b n)
   (define h (/ (- b a) n))
   (define (next x)(+ x 1))
   (define (new-f x)
     (define res (f (+ a (* x h))))
     (cond ((or (= x 0)(= x n)) res)
           ((even? x)(* 2 res) )
           (else (* 4 res))
                     ))
   (* (/ h 3) (h-sum new-f 0 next n))
  )
(define (cube x)(* x x x))

; Higher-order product
(define (h-product f a next b)
  (if (> a b) 1 (* (f a) (h-product f (next a) next b))))
(define (h-product-iter f a next b)
  (define (iter a res)
    (if (> a b) res (iter (next a)(* res a)))
    )
  (iter a 1)
  )
(define (factorial n)
   (define (next n)(+ 1 n))
   (define (f n) n)
   (h-product-iter f 1 next n)
  )

(define (round-to-even n)(if (even? n) n (- n 1)))
(define (round-to-odd n)(if (even? n) (- n 1) n))
(define (calc-pi n)
  (define (plus-2 x)(+ 2 x))
  (* 4.0 (/ (* 2 (h-product square 4 plus-2 n))(* (round-to-odd n)(h-product square 3 plus-2 n)) ))
  )
; accumulator function
(define (accumulate combiner null-value term a next b)
  (if (> a b) null-value (combiner (term a) (accumulate combiner null-value term (next a) next b)))
  )
(define (accumulate-iter combiner null-value term a next b)
   (define (iter a res)
      (if (> a b) res (iter (next a)(combiner res (term a))))
     )
  (iter a null-value)
  )
(define (next n)(+ 1 n))

(define (accumulate-sum a b)
  (accumulate-iter + 0 (lambda (x) x) a (lambda (x)(+ x 1)) b)
  )
; find the fixed point of a function 
(define (find-fixed-point f guess)
  (newline)
  (display guess)
  (define (close-enough? a b)(< (abs (- a b)) 0.00001 ))
  (let ((next (f guess))) (if (close-enough? guess next)
                              0
                              (find-fixed-point f next))                                 
                                   ))

(define (average-damp f)
  (lambda (x)(avg x (f x)))
  )
(define (cont-frac-iter f-n f-d k)
  (define (iter res count)(if (<= count 0) res (iter (/ (f-n count)(+ (f-d count) res)) (- count 1))))
  (iter 0 k)
  )

(define (cont-frac f-n f-d k)
   (if (= k 1) 1 (/ (f-n k) (+ (f-d k) (cont-frac f-n f-d (- k 1))))
  ))
(define (calc-e)
   (+ 2 (cont-frac-iter (lambda (x) 1.0) (lambda (k) (cond((= (remainder (+ k 1) 3) 0) (* 2 (/ (+ k 1) 3)))
                                                          (else 1.0))) 100))
  )

(define (calc-tan radians k)
 (cont-frac-iter (lambda (x) (if (= x 1) radians (-(* radians radians)))) (lambda (n) (- (* 2.0 n) 1.0)) k))

(define dx 0.00001)
(define (deriv f)
   (lambda (x) (/ (- (f (+ x dx))(f x)) dx))
  )

(define (double-f f)
  (lambda (x)(f(f x)))
  )