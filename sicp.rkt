#lang racket
(define (square x) (* x x))
(define (avg x y) (/ (+ x y) 2))
(define (abs x) (if (> x 0) x (- x)))

;square root
(define (sqrt x)
  (define (sqrt-iter guess)(if (good-enough? guess) guess (sqrt-iter (improve-guess guess))))
  (define (good-enough? guess) (if (< (/ (abs (-(improve-guess guess) guess)) guess) 0.001) #t #f))
  (define (improve-guess guess) (avg guess (/ x guess)))
  (sqrt-iter 1.0))
;cube root
(define (cube-root guess x) (if (good-enough-cube? guess x)   guess   (cube-root (improve-guess-cube guess x) x) ))
(define (good-enough-cube? guess x)(if (< (/ (abs (- (improve-guess-cube guess x) guess)) guess) 0.001) #t #f))
(define (improve-guess-cube guess x)(/ (+ (/ x (square guess)) (* 2 guess)) 3))

;f(n) = f(n-1)+2f(n-2)+3f(n-3)
(define (iterative-f n)
  (define (iter-f n3 n2 n1 count) (cond ((< (- count 3) 0) count)
                                      ((= (- count 3) 0) (+ n3 (* 2 n2) (* 3 n1)))
                                      (else (iter-f  (+ n3 (* 2 n2) (* 3 n1)) n3 n2 (- count 1) ))))
  (iter-f 2 1 0 n)
  )
(define (recursive-f n)(if (< n 3) n (+ (recursive-f (- n 1)) (* 2 (recursive-f (- n 2))) (* 3 (recursive-f (- n 3))))))



;pascal's triangle, let x be the row and y be the column
(define (pascal-triangle x y)
  (if (or (= y 1) (= y x))
      1
  (+ (pascal-triangle (- x 1) (- y 1))  (pascal-triangle (- x 1) y ) )
  ))

;Fibonacci
(define (fib n)
  (define (fib-iter a b count)
    (if (= count 0)  a (fib-iter b (+ a b) (- count 1)))
    )
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else   (fib-iter 0 1 n))
        )
  )
(define sqr-5-a (/ (+ 1 (sqrt 5)) 2))
(define sqr-5-b (/ (- 1 (sqrt 5)) 2))
(define (calc n) (/ (- (pow sqr-5-a n) (pow sqr-5-b n)) (sqrt 5)))
; original power
(define (pow num nth)
  (define (pow-iter num res nth)  (if(= nth 0) res (pow-iter num (* res num) (- nth 1))))
  (pow-iter num 1 nth)
)
(define (even? x)(= (remainder x 2)0) )
; fast power 
(define (fast-pow b n)
  (define (fast-row-iter remain res base)(cond ((= remain 0) res)
                                          ((even? remain) (fast-row-iter (/ remain 2) res (square base)))
                                          (else (fast-row-iter (- remain 1) (* res base) base ))))
  (fast-row-iter n 1 b)
  )
; do multiply using double and half
(define (double x) (+ x x))
(define (half x) (/ x 2))
(define (fast-multiply a b)
  (define (fast-multiply-iter remain res base)
    (cond ((= remain 0) res)
          ((even? remain) (fast-multiply-iter (half remain) res (double base)))
          (else (fast-multiply-iter (- remain 1) (+ res base) base))
          )
    )
  (fast-multiply-iter b 0 a)
  )
(define (fast-multiply-recur a b)
   (cond ((= b 1) a)
         ((even? b) (double (fast-multiply-recur a (half b))))
         (else (+ a (fast-multiply-recur a (- b 1)))))
  )
; find prime factor 
(define (smallest-divisor t test-divisor)
  (define (divides? a b)(= (remainder a b) 0))
  (cond ((> (square test-divisor) t) t)
        ((divides? t test-divisor) test-divisor)
        (else (smallest-divisor t (next test-divisor)))
  ))
(define (next d)(if (= d 2) 3 (+ d 2)))

(define (prime? x)
  (= (smallest-divisor x 2) x))
; Fermat
(define (expo-module base exp m)
  (cond ((= exp 1) base)
        ((even? exp)(remainder (square (expo-module base (/ exp 2) m)) m))
        (else (remainder (* base (expo-module  base (- exp 1) m)) m)))
  )
(define (fermat-test n)
  (let ((a (+ 1(random (- n 1)))))(= (expo-module a n n) a ))
  )
(define (Carmichael-numbers n)
  (define (CN-iter count n)
    (cond ((> count (- n 1)) #t)
          ((= (expo-module count n n) count) (CN-iter (+ 1 count) n))
          (else #f)                               )
    )
  (CN-iter 1 n)
  )
 ; Higher-order procedures
